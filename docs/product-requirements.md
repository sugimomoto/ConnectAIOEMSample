# プロダクト要求仕様書: DataHub - Connect AI OEM リファレンス実装

## 1. プロダクトビジョンと目的

### ビジョン
CData Connect AI OEMを組み込んだSaaS製品の理想的な統合パターンを示すリファレンスアプリケーション。パートナー企業が自社製品にデータ統合機能を簡単に組み込めることを実証する。

### 目的
1. **技術実証**: Connect AI OEMのMCPツールを活用したマルチデータソース統合の実装方法を示す
2. **商談支援**: パートナー企業へのデモンストレーションで具体的な統合イメージを提供
3. **開発ガイド**: パートナー企業のエンジニアが参考にできる実装パターンとベストプラクティスの提供
4. **差別化要因の提示**: 低コストで多様なデータソースに対応できるOEMソリューションの価値を明示

## 2. ターゲットユーザーと課題・ニーズ

### プライマリターゲット: SaaS/BIツールベンダーの意思決定者
- **役職**: CTO、プロダクトマネージャー、エンジニアリングリーダー
- **企業規模**: スタートアップ〜中堅企業
- **現在提供している製品**: 分析ツール、ダッシュボード、レポーティングツール、データマネジメントツール

### 解決すべき課題
1. **開発コスト**: 各データソースのAPI個別実装に膨大な工数がかかる
2. **保守負担**: API変更への追従、複数SDKのメンテナンスが困難
3. **市場投入速度**: 新しいデータソース対応に時間がかかり、競合に遅れる
4. **技術的負債**: 各データソースごとに異なるインターフェースで複雑性が増大
5. **人材確保**: 多様なAPI知識を持つエンジニアの採用が困難

### ニーズ
- 統一されたインターフェース（SQL）で多様なデータソースにアクセスしたい
- メタデータAPIで動的にUIを生成し、開発工数を削減したい
- エンドユーザー（自社顧客）に自社ブランドでデータ統合機能を提供したい
- セキュアなマルチテナント構成を実装したい
- 迅速にPoCやMVPを構築して市場フィードバックを得たい

## 3. 主要な機能一覧

### Phase 1: 基本機能（MVP）
1. マルチテナント認証・アカウント管理
2. データソースコネクション管理UI
3. メタデータエクスプローラー（カタログ/スキーマ/テーブル/カラム）

### Phase 2: クエリ・データ操作
4. ビジュアルクエリビルダー（GUIでのSELECT文生成）
5. データCRUD操作（レコード一覧、作成、編集、削除）

### Phase 3: 高度な機能（オプション）
6. マルチソースクエリ（複数コネクションのJOIN）
7. 保存済みクエリ/レポート管理
8. スケジュール実行機能

## 4. 成功の定義

### デモ時の成功指標
- ✅ 5分以内にパートナーが「自社製品への統合イメージ」を理解できる
- ✅ 3つ以上の異なるデータソース（Salesforce, QuickBooks, Azure DevOpsなど）への接続をライブデモできる
- ✅ メタデータ取得からUI自動生成までの流れを実演できる
- ✅ SQLインジェクション対策などのセキュリティ実装を説明できる
- ✅ パートナーから「これなら自社でも実装できそう」というフィードバックを得る

### 技術的成功指標
- ✅ 各データソースへの接続・クエリが正常に動作する
- ✅ レスポンスタイム: メタデータ取得 < 3秒、クエリ実行 < 5秒
- ✅ エラーハンドリングが適切に実装されている
- ✅ コードがクリーンで、パートナーエンジニアが読みやすい

## 5. ユーザーストーリー

### ストーリー1: 初回セットアップ
**As a** SaaSプロダクトのエンドユーザー
**I want to** 自分のSalesforceアカウントを接続する
**So that** 自社のCRMデータを分析ツールで活用できる

**受け入れ基準**:
- 新規ユーザー登録ができる
  - メールアドレス、パスワード、名前を入力
  - 登録時に自動的にConnect AI側に子アカウントが作成される（externalIdとしてユーザーIDを使用）
- Salesforceコネクション作成フォームで必要なパラメータ（URL, Client ID, Client Secretなど）を入力できる
- 「接続テスト」ボタンで接続が成功することを確認できる
- 接続したコネクションが一覧に表示される

**技術的な流れ**:
1. ユーザーがメール/パスワードで登録
2. アプリケーションがローカルDBにユーザーレコード作成（user_id = 123）
3. アプリケーションがConnect AI Account APIを呼び出し: `POST /poweredby/account/create { "externalId": "123" }`
4. Connect AIが子アカウントを作成し、`accountId`を返却
5. アプリケーションが`accountId`をユーザーレコードに保存
6. 以降のコネクション作成時は、この`accountId`を使用してConnect AI側のテナント分離を実現

### ストーリー2: データ構造の探索
**As a** ビジネスアナリスト
**I want to** 接続したデータソースのテーブル構造を視覚的に確認する
**So that** どのようなデータが利用可能か把握できる

**受け入れ基準**:
- コネクション選択後、カタログ一覧が表示される
- スキーマ → テーブル → カラムとドリルダウンできる
- 各カラムのデータ型、NULL可否などのメタデータが表示される
- 検索・フィルタリング機能でテーブルを素早く見つけられる

### ストーリー3: データのクエリ
**As a** データアナリスト
**I want to** SQLを書かずにGUIでクエリを作成する
**So that** 技術的なスキルがなくてもデータを取得できる

**受け入れ基準**:
- テーブルを選択すると、カラム一覧が表示される
- チェックボックスで取得するカラムを選択できる
- WHERE条件をGUIで設定できる（カラム、演算子、値）
- 「実行」ボタンでクエリが実行され、結果がテーブル表示される
- 生成されたSQL文を確認できる
- 結果をCSV/JSONでエクスポートできる

### ストーリー4: データの編集
**As a** データ管理者
**I want to** 既存レコードを編集・削除する
**So that** データの正確性を維持できる

**受け入れ基準**:
- テーブルのレコード一覧をページネーション付きで表示できる
- 各レコードの「編集」ボタンで編集フォームが開く
- フォームはカラムメタデータから自動生成される
- 保存時にUPDATE文が実行され、成功・失敗メッセージが表示される
- 削除時に確認ダイアログが表示される

### ストーリー5: マルチソース統合（Phase 3）
**As a** 財務アナリスト
**I want to** SalesforceのOpportunityとQuickBooksのInvoiceをJOINする
**So that** 受注から請求までの売上分析ができる

**受け入れ基準**:
- 複数コネクションから異なるテーブルを選択できる
- JOIN条件をGUIで設定できる
- 実行結果が正しく統合されて表示される

## 6. 機能要件

### 6.1 認証・アカウント管理
- **FR-AUTH-001**: メールアドレスとパスワードでユーザー登録できる
  - ローカルデータベースにユーザー情報を保存
  - 登録時にユーザーIDを`externalId`としてConnect AI Account API (`/poweredby/account/create`) を呼び出し
  - 返却された`accountId`をローカルデータベースに保存
- **FR-AUTH-002**: ログイン・ログアウト機能
  - アプリケーション側の認証（メール/パスワード検証）
  - Connect AIへの認証は各API呼び出し時にJWTトークンで実施
- **FR-AUTH-003**: セッション管理（JWT）
  - アプリケーション側のJWTトークンでユーザーセッションを管理
  - Connect AI API呼び出し時は別途Connect AI用JWTトークンを生成
- **FR-AUTH-004**: テナント分離（ユーザーは自分のコネクションのみアクセス可能）
  - ローカルデータベースのRow Level Securityで実装
  - Connect AI側も`accountId`（子アカウント）でテナント分離
- **FR-AUTH-005**: Connect AI Account APIとの連携
  - ユーザー登録時: `POST /poweredby/account/create` で子アカウント作成
  - `externalId`: アプリケーション側のユーザーID
  - `accountId`: Connect AIの内部アカウントID（コネクション作成時に使用）

### 6.2 コネクション管理
- **FR-CONN-001**: 新規コネクション作成フォーム
  - Connection Name（コネクション名）の入力
  - Data Source Name（データソース種別、例：Salesforce、QuickBooks、Azure DevOps）の選択
  - Connect AI Connection API (`/poweredby/connection/create`) を呼び出し、返却された`redirectURL`にユーザーをリダイレクト
  - ユーザーがCData Connect AIの画面でデータソースの認証情報を入力・完了後、アプリへリダイレクト
- **FR-CONN-002**: コネクション一覧表示
- **FR-CONN-003**: コネクション削除

### 6.3 メタデータエクスプローラー
- **FR-META-001**: カタログ一覧取得・表示（`getCatalogs`）
- **FR-META-002**: スキーマ一覧取得・表示（`getSchemas`）
- **FR-META-003**: テーブル一覧取得・表示（`getTables`）
- **FR-META-004**: カラム詳細表示（`getColumns`）
  - カラム名、データ型、NULL可否、主キー、外部キーなど
- **FR-META-005**: 検索・フィルタリング機能
- **FR-META-006**: ツリービューまたはブレッドクラム型ナビゲーション

### 6.4 クエリビルダー
- **FR-QUERY-001**: テーブル選択UI
- **FR-QUERY-002**: カラム選択（マルチセレクト）
- **FR-QUERY-003**: WHERE条件設定
  - カラム選択
  - 演算子選択（=, <>, <, >, <=, >=, LIKE, IN, BETWEEN）
  - 値入力（パラメータ化）
- **FR-QUERY-004**: ORDER BY設定（カラム選択、ASC/DESC）
- **FR-QUERY-005**: LIMIT/OFFSET設定（ページネーション）
- **FR-QUERY-006**: SQL文プレビュー表示
- **FR-QUERY-007**: クエリ実行（`queryData`）
- **FR-QUERY-008**: 結果表示（テーブル形式）
- **FR-QUERY-009**: エクスポート機能（CSV, JSON）

### 6.5 データCRUD操作
- **FR-CRUD-001**: レコード一覧表示（SELECT）
  - ページネーション（デフォルト20件/ページ）
  - ソート機能
- **FR-CRUD-002**: 新規レコード作成
  - カラムメタデータからフォーム自動生成
  - INSERT文実行
- **FR-CRUD-003**: レコード編集
  - 既存データのプリフィル
  - UPDATE文実行
- **FR-CRUD-004**: レコード削除
  - 確認ダイアログ
  - DELETE文実行
- **FR-CRUD-005**: エラーメッセージ表示（データソース側のエラーを適切に表示）

### 6.6 マルチソースクエリ（Phase 3）
- **FR-MULTI-001**: 複数コネクションからテーブル選択
- **FR-MULTI-002**: JOIN設定（INNER, LEFT）
- **FR-MULTI-003**: JOIN条件設定
- **FR-MULTI-004**: 統合クエリ実行

### 6.7 保存済みクエリ（Phase 3）
- **FR-SAVED-001**: クエリの保存（名前、説明）
- **FR-SAVED-002**: 保存済みクエリ一覧
- **FR-SAVED-003**: 保存済みクエリの実行
- **FR-SAVED-004**: 保存済みクエリの編集・削除

## 7. 非機能要件（デモ用・最小限）

**注**: 本アプリケーションはデモ用途でローカル環境での動作を想定しているため、非機能要件は最小限に絞っています。

### 7.1 セキュリティ（必須）
- **NFR-SEC-001**: すべてのクエリはパラメータ化され、SQLインジェクションを防止する
  - ユーザー入力を直接SQL文に埋め込まない
  - Connect AI API の `parameters` オプションを必ず使用
- **NFR-SEC-002**: パスワードはハッシュ化して保存する
  - bcryptを使用（cost factor: 10以上推奨）
  - 平文パスワードは絶対に保存しない
- **NFR-SEC-003**: テナント分離を実装する
  - ユーザーは自分のデータのみアクセス可能
  - データベースクエリに `WHERE user_id = :current_user` を自動付与

### 7.2 開発環境（推奨）
- **NFR-DEV-001**: 環境変数で設定を管理する（.env）
- **NFR-DEV-002**: READMEに環境構築手順を記載する
- **NFR-DEV-003**: エラー発生時はコンソールにログ出力する（簡易的なログ記録）

## 8. 受け入れ条件と優先順位

### Phase 1: MVP（必須 - 2週間）
**目標**: パートナーに基本的な統合パターンを示せる最小限の機能

| ID | 機能 | 優先度 | 受け入れ条件 |
|----|------|--------|------------|
| MVP-1 | ユーザー登録・ログイン | P0 | メール/パスワードでの認証が動作する |
| MVP-2 | コネクション作成 | P0 | Salesforce, QuickBooks, Azure DevOpsのいずれか1つに接続できる |
| MVP-3 | 接続テスト | P0 | 接続の成功/失敗が判定できる |
| MVP-4 | コネクション一覧 | P0 | 作成したコネクションが一覧表示される |
| MVP-5 | メタデータエクスプローラー | P0 | カタログ→スキーマ→テーブル→カラムのドリルダウンができる |
| MVP-6 | カラム詳細表示 | P0 | データ型、NULL可否などが表示される |

**MVP完了の定義**:
- ✅ 1つのデータソースに接続し、テーブル構造を閲覧できる
- ✅ マルチテナントで各ユーザーのコネクションが分離される
- ✅ エラーハンドリングが実装され、クラッシュしない
- ✅ 基本的なセキュリティ対策（パスワードハッシュ化、パラメータ化クエリ）が実装される

### Phase 2: クエリ・CRUD機能（重要 - 2週間）
**目標**: データ操作の実用性を示し、メタデータ活用の利点を明確化

| ID | 機能 | 優先度 | 受け入れ条件 |
|----|------|--------|------------|
| P2-1 | ビジュアルクエリビルダー | P0 | GUI操作でSELECT文を生成・実行できる |
| P2-2 | WHERE条件設定 | P0 | 複数条件を組み合わせられる |
| P2-3 | クエリ結果表示 | P0 | テーブル形式で結果が見やすく表示される |
| P2-4 | CSVエクスポート | P1 | 結果をCSVダウンロードできる |
| P2-5 | レコード一覧 | P0 | ページネーション付きで表示される |
| P2-6 | レコード作成 | P0 | フォームが自動生成され、INSERTできる |
| P2-7 | レコード編集 | P1 | 既存データを編集できる |
| P2-8 | レコード削除 | P1 | 確認後に削除できる |

**Phase 2完了の定義**:
- ✅ SQLを書かずにデータのクエリ・CRUD操作ができる
- ✅ メタデータから動的にUIが生成される様子をデモできる
- ✅ 3つ以上の異なるデータソースで動作確認済み

### Phase 3: 高度な機能（あれば良い - 1-2週間）
**目標**: Connect AI OEMの差別化要因を最大限アピール

| ID | 機能 | 優先度 | 受け入れ条件 |
|----|------|--------|------------|
| P3-1 | マルチソースJOIN | P2 | 2つのコネクションのテーブルをJOINできる |
| P3-2 | 保存済みクエリ | P2 | クエリを保存・再実行できる |
| P3-3 | スケジュール実行 | P3 | 定期的にクエリを実行できる |
| P3-4 | JSONエクスポート | P2 | JSON形式でエクスポートできる |
| P3-5 | ストアドプロシージャ実行 | P2 | `executeProcedure`を使用できる |

**Phase 3完了の定義**:
- ✅ マルチソースクエリでConnect AIの強みを明確に示せる
- ✅ 保存済みクエリで「実用的な製品」のイメージを与えられる

## 優先順位の考え方
- **P0 (Must Have)**: MVP/Phase完了に必須。これがないとデモできない
- **P1 (Should Have)**: 重要だが、最初のデモには必須ではない
- **P2 (Nice to Have)**: あるとアピール力が増すが、時間がなければスキップ可能
- **P3 (Future)**: 将来的に追加検討

## 次のステップ
1. Phase 1のMVP機能から実装を開始
2. 各フェーズ完了後にパートナーデモを実施してフィードバック収集
3. フィードバックに基づいて次フェーズの優先順位を調整

---

## 実装の進め方（参考）

### 技術スタック（再確認）
- **Backend**: Python 3.9+, Flask or FastAPI
- **Database**: SQLite（開発）/ PostgreSQL（本番想定）
- **Frontend**: HTML5, CSS3 (Bootstrap or Tailwind), Vanilla JavaScript or Vue.js（軽量）
- **認証**: Flask-Login or FastAPI Security
- **ORM**: SQLAlchemy
- **Connect AI**: MCP Tools（既存）

### プロジェクト構造
```
ConnectAIOEMSample/
├── backend/
│   ├── app.py                    # Flaskアプリケーション
│   ├── models.py                 # User, Connection DBモデル
│   ├── auth.py                   # 認証ロジック
│   ├── connectai/
│   │   ├── __init__.py
│   │   ├── client.py             # MCP Tools ラッパー
│   │   └── utils.py              # ヘルパー関数
│   ├── api/
│   │   ├── __init__.py
│   │   ├── auth_routes.py        # /api/auth/*
│   │   ├── connection_routes.py  # /api/connections/*
│   │   ├── metadata_routes.py    # /api/metadata/*
│   │   └── query_routes.py       # /api/queries/*
│   ├── config.py                 # 設定管理
│   └── requirements.txt
├── frontend/
│   ├── index.html
│   ├── login.html
│   ├── dashboard.html
│   ├── connections.html
│   ├── explorer.html
│   ├── query.html
│   ├── static/
│   │   ├── css/
│   │   ├── js/
│   │   └── img/
├── docs/
│   └── PARTNER_INTEGRATION_GUIDE.md
├── tests/
│   ├── test_auth.py
│   ├── test_connections.py
│   └── test_queries.py
├── .env.example
├── .gitignore
├── README.md
└── CLAUDE.md
```

### 検証方法
1. **ユニットテスト**: pytest で各APIエンドポイントをテスト
2. **統合テスト**: 実際のConnect AIコネクションを使用したE2Eテスト
3. **手動テスト**: チェックリストに基づくブラウザでの動作確認
4. **セキュリティチェック**: SQLインジェクション、XSS、CSRF対策の検証
5. **パフォーマンステスト**: 大量データでのクエリ実行時間測定
